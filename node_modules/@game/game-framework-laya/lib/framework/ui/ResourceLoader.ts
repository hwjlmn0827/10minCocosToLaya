import HttpRequest from '../network/HttpRequest';

/**
 * 资源加载器
 */
export default class ResourceLoader {

  private static bitmapFontMap: Map<string, Laya.BitmapFont> = new Map<string, Laya.BitmapFont>();
  /**
   * 并行加载，不分先后顺序
   * 支持加载任何资源 包括request
   * @param arr 资源数组 （或者request）
   * @param caller 执行域名
   * @param callback 加载回调
   */
  public static load(
    arr: (string | HttpRequest | Promise<any>)[],
    caller: any,
    callback: Function
  ): void {
    let promiseArr = [];
    let commonArray = [];
    for (let i = 0; i < arr.length; i++) {
      let item = arr[i];
      if (typeof item == 'string') {
        let isFont = item.indexOf('.fnt') > 0;
        if (isFont) {
          promiseArr.push(this.loadFont(item));
        } else {
          commonArray.push(item);
        }
      } else if (item instanceof HttpRequest) {
        promiseArr.push(this.loadHttpRequest(item));
      } else if (item instanceof Promise) {
        promiseArr.push(item);
      }
    }

    if (commonArray.length > 0) {
      promiseArr.push(this.loadCommon(commonArray));
    }

    Promise.all(promiseArr)
      .then(() => {
        Laya.timer.once(1, this, () => {
          let handler = Laya.Handler.create(caller, callback);
          handler.runWith(true);
        });
      })
      .catch( error=> {
        console.error('[ResourceLoader] load callback', error);
        let handler = Laya.Handler.create(caller, callback);
        handler.runWith([false, error]);
      });
  }

  public static loadHttpRequest(request: HttpRequest): Promise<any> {
    return new Promise((resolve, reject) => {
      request.addResponseCallback(this, (isSuccess, data) => {
        if (isSuccess) {
          resolve({});
        } else {
          reject({
            isRequest: true,
            data: data
          });
        }
      });
      request.send();
    });
  }

  public static loadFont(fontPath: string): Promise<any> {
    return new Promise((resolve, reject) => {
      if(this.bitmapFontMap.has(fontPath)){
        resolve({});
      }else{
        let bitmapFont: Laya.BitmapFont = new Laya.BitmapFont();
        this.bitmapFontMap.set(fontPath, bitmapFont);
        bitmapFont.loadFont(
          fontPath,
          new Laya.Handler(this, isSuccess => {
            if (isSuccess) {
              let startIndex = fontPath.lastIndexOf('/') + 1;
              let fntIndex = fontPath.indexOf('.fnt');
              if (fntIndex > 0) {
                let fontName = fontPath.substring(startIndex, fntIndex);
                Laya.Text.registerBitmapFont(fontName, bitmapFont);
              }
              resolve({});
            } else {
              reject({
                isFont: true,
                data: fontPath
              });
            }
          })
        );
      }
    });
  }

  public static removeFont(fontPath:string){
    let bitmapFont: Laya.BitmapFont = this.bitmapFontMap.get(fontPath);
    if(bitmapFont){
      bitmapFont.destroy();
      this.bitmapFontMap.delete(fontPath);
    }
  }

  private static loadCommon(commonPathArray: string[]): Promise<any> {
    return new Promise((resolve, reject) => {
      Laya.loader.load(
        commonPathArray,
        Laya.Handler.create(this, function(isSuccess) {
          if (isSuccess) {
            resolve({});
          } else {
            reject({
              isResource: true,
              data: commonPathArray
            });
          }
        })
      );
    });
  }

  
}
